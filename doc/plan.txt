TODO:       主要类结构
            场景管理
                场景树
                各种渲染对象属性和方法声明；
                    摄像机
                    网格
                    光源
                        frustum, shadow;
                    Decal
                    envprobe
                    irradiance volume
                对象更新；
            图元分发
                摄像机列表
                渲染图元对象定义；
                图元列表；
                    depth prepass
                    opaque
                    transparent
                    sprite? particle system?
                光源列表
                Decal 列表
                Cubemap 列表
                Irradiance volume 列表
                场景遍历，对象和图元分发
                初始化GL
            材质
                材质对象定义
                    RenderState Cache
                    标准 PBR 材质属性
            RenderTarget
                创建纹理和 RenderBuffer；注意创建的纹理和读取的纹理的关系；
            Shader架构
                Shader 预处理，加载，编译；
                    先用js字符串形式的shader源码测试；
                    实现 #include 机制；
                    以后再实现加载远程 shader 文件？
                命名规则
                Shader 输入、输出定义
                    thin g-buffer, for subsurface scattering, local reflection
                Uniform buffer对象封装
                Uniform buffer 定义：每帧，每View，每物体，每材质
                Uniform buffer 对象放在哪？shaderProgram 对象里？材质对象里？渲染器对象里？
                Uniform buffer 绑定
                渲染器中定义uniform buffer布局
                Vertex Attribute 解析
                Shader 代码结构
                    预置函数，预置变量定义和实现；
                Shader 是否也用缓存？或者为了简单起见，不用缓存了？
                渲染器中加载各种shader；
                    Shader文件和代码段key的命名规则
                    先实现 单色 shader, 测试绘制流程
                    再实现 depth prepass shader, 标准 PBR Shader
                Fix me: Fog 是在材质 Shader 中实现，还是用后期特效实现？
                    不透明物体，可用后期特效
                    半透明物体用材质 shader？
                    或者统一用材质 shader；
            简单Geometry生成、添加、绘制测试
                创建顶点缓冲；Vertex Attribute；Index buffer;
                Box，Sphere，Plane, 用于测试绘制；
                遍历图元列表，绘制
                    光源等非网格对象的 providePrimitive 也得调用，绘制调试图形；
                    Fustum culling; 
                    设置顶点Attribute pointer
                    * 如何在 depth prepass 时使用特殊的 shader？
                        不修改使用的shader；如果关闭了 color write，且 shader 中不使用 discard，则不会执行 shader，opengl 底层会使用一个默认的简单 shader 绘制
                        或者使用一组统一的 shader 来绘制；有镂空纹理的物体不绘制 depth prepass；
                        或者单独写一个带镂空纹理的 depth prepass shader，遇到有 alphaclip = true 的 PBR 材质，则使用这个 shader;
                            PBR 材质的贴图参数统一命名；材质中不带 shader, 使用统一的PBR 标准 shader 绘制；
                            自定义材质的某些贴图参数名称是否也要求统一命名？例如 opacity texture
                    Occlusion query?
                        在RenderItem上加一个是否需要Occlustion query的标志
                        将需要Occlusion query 的RenderItem 挑出来单放一个列表里
                        每帧先绘制不需要 quary 的（例如墙壁、地板、屋顶等），再绘制 query 的（房间中的细节物体）RenderItem 的包围盒
                        本帧 query，下帧才能拿结果，所以每帧都是根据上一帧包围盒的 query 结果绘制细节物体；
                当对象从场景移除时，释放显存资源；
                    加一个显式的 destory 接口？
                简单旋转动画；
                    使用 behavior 控制动画？
                    计时器对象；
                绘制视空间法线；检查背面剔除和法线是否正确；
                摄像机lookat控制？
                
            先实现简单的 forward shading
            直接光照
                添加光源到场景；
                    Shader 中取光源等 item 的函数
                    在 fragment shader 中变换光源到视空间？还是统一用世界空间计算？
                        变换像素的法线和位置到世界空间是否性能更好一些；可以避免将遍历到的每个光源、贴花等都变换到视空间
                PBR 光照计算
                多光源；
                测试各种光源类型；
                测试材质的各种参数；
                    TODO: emissive 和 opacity color
                阴影；
                    实现和测试设置 RenderTarget
                        实现和测试画到屏幕的二维矩形 shader
                        渲染到一张纹理，然后贴到场景中的物体表面；
                        屏幕矩形图元；或者屏幕矩形shader；
                        据说 FrameBufferObject 中切换 attached texture 要比切换 FrameBufferObject 快？
                            需要实现 FrameBufferObject 的灵活切换 attached texture 的方法？
                            暂时没必要；持各种观点的人都有，未必对性能影响那么大
                    先测试只有一个光源的阴影；动态光影；
                        实现 shadowmap shader；
                        给光源渲染 shadow map，在屏幕矩形上显示，用于调试
                        使用 depth texture 作为 Shadowmap，传入shader;
                        pbr shader 中计算光照时取样 shadowmap，
                            注意要使用 samplerShadow 类型
                        进一步软阴影；
                        测试不同类型光源的阴影；
                        实现点光源阴影？
                    Shadow map atlas; 
                        如何处理光源的 atlas rect size 变化的情况？还是一旦光源建立，就不允许改了？
                            重构一下，在 lightshadow 上记录 shadow rect 的尺寸，以及当前在 atlas 中的位置；
                            用户只能修改 rect 尺寸；当修改了尺寸后，dispatchobject 时发现与当前尺寸不一致了，就从旧列表中移除，添加到新列表；
                            能否将 lightshadow 和 atlas 位置解耦，将其对应关系以 map 的形式保存在 shadowmapAtlas 对象里？
                                renderer 每次更新 shadowmap 时都需要查询；
                    阴影的动态和静态更新逻辑
                        能否静态和动态光源都使用同一张 shadow map atlas 和统一的逻辑？
                        静态光源和动态光源的区别：前者不会实时添加或删除，也不能移动或改颜色；后者是实时添加或删除的光源，可以移动、改属性；
                            但是两种类型的光源都可以更新阴影；
                            或者能否利用 unform buffer 的 subData 函数，只更新改变过的光源数据，使所有光源都能修改属性？
                        光源设置一个标志：是否需要更新阴影
                            在光源对象 update 时判断
                                如果光源运动了，设为 true；
                                如果光源内有运动的或有动画的动态 mesh，设为 true
                            每帧遍历检查光源是否可见时，如果光源可见且标志为 true，则更新shadowmap，然后将标志置 false;
                    如何处理带有镂空纹理的材质
                        * 也按照和 depth prepass 类似的方法处理
            实现 Frustum culling?
                有了此功能，才能判断光源中是否有活动的动态物体；
            
            测试 Occlusion query?
                调试绘制：Occlusion test 失败的，画一个不会被遮挡的线框 box？

            间接光照
                RenderTarget; 渲染到cubemap；
                image based lighting
                生成 envmap cube（64 x 64）
                    生成 mipmaps？
                生成 irradiance volume？或者尝试用low mipmap envmap cube 做间接光照？

            贴图
                sampler state
                贴图的属性
                贴图的加载和绑定
            FileLoader
            GLTFLoader
                先直接引用 minimal gltf loader?
                读取mesh, material, texture
                File Cache
                Geometry Cache
                    所有从 gltf 文件加载的 geometry，统一用文件名 + 网格名生成一个key，放在 cache 中；多个 mesh 共享之；
                        注意这种 geometry 要标一下 incache，在对象 release 时避免释放它；由cache统一释放；
                Texture cache
                    用纹理文件 url 作为 key
                读取light, decal, envprobe, irradiance volume;



            SSAO，屏幕空间反射；subsurface scattering

            Clustered 光源、envmap、irradiance volume

            particle system; sprite;

            从GLTF加载组件信息？
                    读取object的自定义属性：组件列表和组件属性？或者prefab文件名？
                    使用json定义object prefab对象？

LOG：


