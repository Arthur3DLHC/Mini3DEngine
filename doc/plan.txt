TODO:       主要类结构
            场景管理
                场景树
                各种渲染对象属性和方法声明；
                    摄像机
                    网格
                    光源
                        frustum, shadow;
                    Decal
                    envprobe
                    irradiance volume
                对象更新；
            图元分发
                摄像机列表
                渲染图元对象定义；
                图元列表；
                    depth prepass
                    opaque
                    transparent
                    sprite? particle system?
                光源列表
                Decal 列表
                Cubemap 列表
                Irradiance volume 列表
                场景遍历，对象和图元分发
                初始化GL
            材质
                材质对象定义
                    RenderState Cache
                    标准 PBR 材质属性
            RenderTarget
                创建纹理和 RenderBuffer；注意创建的纹理和读取的纹理的关系；
            Shader架构
                Shader 预处理，加载，编译；
                    先用js字符串形式的shader源码测试；
                    实现 #include 机制；
                    以后再实现加载远程 shader 文件？
                命名规则
                Shader 输入、输出定义
                    thin g-buffer, for subsurface scattering, local reflection
                Uniform buffer对象封装
                Uniform buffer 定义：每帧，每View，每物体，每材质
                Uniform buffer 对象放在哪？shaderProgram 对象里？材质对象里？渲染器对象里？
                Uniform buffer 绑定
                渲染器中定义uniform buffer布局
                Vertex Attribute 解析
                Shader 代码结构
                    预置函数，预置变量定义和实现；
                Shader 是否也用缓存？或者为了简单起见，不用缓存了？
                渲染器中加载各种shader；
                    Shader文件和代码段key的命名规则
                    先实现 单色 shader, 测试绘制流程
                    再实现 depth prepass shader, 标准 PBR Shader
                Fix me: Fog 是在材质 Shader 中实现，还是用后期特效实现？
                    不透明物体，可用后期特效
                    半透明物体用材质 shader？
                    或者统一用材质 shader；
            简单Geometry生成、添加、绘制测试
                创建顶点缓冲；Vertex Attribute；Index buffer;
                Box，Sphere，Plane, 用于测试绘制；
                遍历图元列表，绘制
                    光源等非网格对象的 providePrimitive 也得调用，绘制调试图形；
                    Fustum culling; 
                    设置顶点Attribute pointer
                    * 如何在 depth prepass 时使用特殊的 shader？
                        不修改使用的shader；如果关闭了 color write，且 shader 中不使用 discard，则不会执行 shader，opengl 底层会使用一个默认的简单 shader 绘制
                        或者使用一组统一的 shader 来绘制；有镂空纹理的物体不绘制 depth prepass；
                        或者单独写一个带镂空纹理的 depth prepass shader，遇到有 alphaclip = true 的 PBR 材质，则使用这个 shader;
                            PBR 材质的贴图参数统一命名；材质中不带 shader, 使用统一的PBR 标准 shader 绘制；
                            自定义材质的某些贴图参数名称是否也要求统一命名？例如 opacity texture
                    Occlusion query?
                        在RenderItem上加一个是否需要Occlustion query的标志
                        将需要Occlusion query 的RenderItem 挑出来单放一个列表里
                        每帧先绘制不需要 quary 的（例如墙壁、地板、屋顶等），再绘制 query 的（房间中的细节物体）RenderItem 的包围盒
                        本帧 query，下帧才能拿结果，所以每帧都是根据上一帧包围盒的 query 结果绘制细节物体；
                当对象从场景移除时，释放显存资源；
                    加一个显式的 destory 接口？
                简单旋转动画；
                    使用 behavior 控制动画？
                    计时器对象；
                绘制视空间法线；检查背面剔除和法线是否正确；
                摄像机lookat控制？
                
            先实现简单的 forward shading
            直接光照
                添加光源到场景；
                    Shader 中取光源等 item 的函数
                    在 fragment shader 中变换光源到视空间？还是统一用世界空间计算？
                        变换像素的法线和位置到世界空间是否性能更好一些；可以避免将遍历到的每个光源、贴花等都变换到视空间
                PBR 光照计算
                多光源；
                测试各种光源类型；
                测试材质的各种参数；
                    TODO: emissive 和 opacity color
                阴影；
                    实现和测试设置 RenderTarget
                        实现和测试画到屏幕的二维矩形 shader
                        渲染到一张纹理，然后贴到场景中的物体表面；
                        屏幕矩形图元；或者屏幕矩形shader；
                        据说 FrameBufferObject 中切换 attached texture 要比切换 FrameBufferObject 快？
                            需要实现 FrameBufferObject 的灵活切换 attached texture 的方法？
                            暂时没必要；持各种观点的人都有，未必对性能影响那么大
                    先测试只有一个光源的阴影；动态光影；
                        实现 shadowmap shader；
                        给光源渲染 shadow map，在屏幕矩形上显示，用于调试
                        使用 depth texture 作为 Shadowmap，传入shader;
                        pbr shader 中计算光照时取样 shadowmap，
                            注意要使用 samplerShadow 类型
                        进一步软阴影；
                        测试不同类型光源的阴影；
                        实现点光源阴影？
                    Shadow map atlas; 
                        如何处理光源的 atlas rect size 变化的情况？还是一旦光源建立，就不允许改了？
                            重构一下，在 lightshadow 上记录 shadow rect 的尺寸，以及当前在 atlas 中的位置；
                            用户只能修改 rect 尺寸；当修改了尺寸后，dispatchobject 时发现与当前尺寸不一致了，就从旧列表中移除，添加到新列表；
                            能否将 lightshadow 和 atlas 位置解耦，将其对应关系以 map 的形式保存在 shadowmapAtlas 对象里？
                                renderer 每次更新 shadowmap 时都需要查询；
                    阴影的动态和静态更新逻辑
                        实现 Frustum culling?
                            有了此功能，才能判断光源中是否有活动的动态物体；
                            给光源生成 frustum
                        网格的包围球和包围盒
                            用包围球可能简单一些；无论怎么变换都是球；
                        静态光源和动态光源的区别：前者不会实时添加或删除，也不能移动或改颜色；后者是实时添加或删除的光源，可以移动、改属性；
                            但是两种类型的光源都可以更新阴影；
                            或者能否利用 unform buffer 的 subData 函数，只更新改变过的光源数据，使所有光源都能修改属性？
                        光源设置一个标志：是否需要更新阴影；维护一个本帧可见光源列表；
                            在光源对象 update 时判断: 如果光源运动了，设为 true；
                            在dispatchObject时，挑出运动的且可投影的物体放到一个列表，与所有当前可见的光源判断是否在其视野中；
                            每帧遍历可见光源且标志为 true，则更新shadowmap，然后将标志置 false;
                        测试物体包围球和光源 frustum 的相交判断；
                        优化：区分动态阴影和静态阴影的意义：
                            使用两张shadowmap，
                            静态shadowmap中只有标记为静态的物体；动态shadowmap中只有标记为动态的物体
                            静态物体的shadowmap可以只生成一次；
                            只有动态物体在光源内运动时，才将该物体绘制到动态shadowmap
                            问题：shader中每个光源都需要sample两张纹理
                        实现简单的相机控制；
                    如何处理带有镂空纹理的材质
                        * 也按照和 depth prepass 类似的方法处理
                    Mesh, light 对相机 Frustum 的剔除；
                    优化：应该通过 gl.BlitFrameBuffer 将静态阴影图集中的子图拷贝到动态阴影图集；
                        维护两个纹理，两个FBO：shadowmapAtlas 和 shadowmapCacheAtlas
                        shader 中只使用 shadowmapAtlas
                        一个标志：cacheDirty
                        当光源运动时
                            清 shadowmapAtlas
                            直接向 ShadowmapAtlas 中渲染静态和动态物体
                            置 cacheDirty = true
                        当光源不动时
                            置 cacheCopied = false;
                            如果 cacheDirty == true,
                                清 shadowmapCacheAtlas; 
                                渲染所有静态物体到 shadowmapCacheAtlas;
                                将 cache 拷贝到 shadowmapAtlas
                                置 cacheCopied = true;
                                置 cacheDirty = false
                            如果光源中有动态物体，则
                                如果 cacheCopied == false，拷贝；
                                向 shadowmapAtlas 中渲染动态物体（不清深度缓冲）
-----------------------------------------------------

                    点光源的阴影；
                        怎样为点光源阴影申请图集子图？
                            需要向阴影图集中渲染六次；占用六个子图；
                            将列表中的六个元素都记录为该 lightShadow 对象
                            在 lightShadow 中使用一个列表来记录子图矩形？
                            对 shadowmap 分辨率做限制，不能使用太高分辨率的？

                        怎样在 Shader 中使用
                            由于点光源的变换矩阵不用完整传入，只传入一个中心点位置即可，
                                利用 worldMatrix 和 projMatrix 余下的总共 7 个 vec4 传入所有子图的矩形位置？
                            shader 中判断如果是点光源，需要计算像素处于哪个 frustum，获得 cubeface 编号；
                            根据 cubeface 编号计算视空间的三个轴vx, vy, vz;
                                posLightLocal = （像素位置 - 光源位置）;
                                posView.x = dot(posLightLocal, vx);
                                posView.y = dot(posLightLocal, vy);
                                posView.z = dot(posLightLocal, vz); // 实际上这三步可以通过直接取该轴对应的分量完成，简化运算
                                posProj = matShadowProj * posView;  // matShadowProj 是一个统一的矩形常量，可以在光源循环外创建；
                                posNDC = posProj / w;
                                uvw = posNDC 应用子图视口变换；

                        测试
                            做一个比较适合检查点光源投影的场景

            Instancing？

            间接光照
                RenderTarget; 渲染到cubemap；
                生成 envmap cube（64 x 64）
                    生成 mipmaps？如何进行卷积过滤？

                image based lighting

                生成 irradiance volume？或者尝试用low mipmap envmap cube 做间接光照？
                    为每个 envmap probe 生成一个 shadowmap，用以剔除影响范围外的物体
                        该 shadowmap 中只绘制开启了 occlusion query 的静态物体；这样房间内的细节物体的背向 probe 中心点的面不会被剔除，也可以有环境光照。

            SSAO，屏幕空间反射, 屏幕空间 GI？；

            Subsurface scattering
                参考Khronos Group glTF Viewer; Blender;
            
            测试 Occlusion query?
                调试绘制：Occlusion test 失败的，画一个不会被遮挡的线框 box？或者用不同颜色线框区分被遮挡/无遮挡的物体
                Occlusion query object 分组；用 instancing 方式绘制？因为都是 box

            Clustered 光源、envmap、irradiance volume
                fillItemsPerView
                    加一个参数：checkClusters
                        主画面渲染，设为true;
                        Cubemap 或 Shadowmap 渲染，设为 false；分辨率较低，而且是类似 bake 阶段，无需 Clustered

            加载贴图
                sampler state
                贴图的属性
                贴图的加载和绑定
            FileLoader
            GLTFLoader
                从 Blender 导出测试用的模型
                先直接引用 minimal gltf loader? 或者参考Khronos Group glTF Viewer
                读取mesh, material, texture
                File Cache
                Geometry Cache
                    所有从 gltf 文件加载的 geometry，统一用文件名 + 网格名生成一个key，放在 cache 中；多个 mesh 共享之；
                        注意这种 geometry 要标一下 incache，在对象 release 时避免释放它；由cache统一释放；
                Texture cache
                    用纹理文件 url 作为 key
                读取light, decal, envprobe, irradiance volume;

            资源加载器
                资源列表和资源计数？
                所有资源加载完后再开始逻辑循环？

            particle system; sprite;

            从GLTF加载组件信息？
                读取object的自定义属性：组件列表和组件属性？或者prefab文件名？
                或者使用命名规范、前缀来定义；
                使用json定义object prefab对象；
                区分哪些网格是 occluder，哪些网格需要 occlusion query；使用前缀？
                Blender 中的光源属性是否齐全？怎样使用；导出光源场景测试
                Blender 中能否导出 instancing 的网格？导出有 linked duplicate 网格场景测试

LOG：


