TODO:       主要类结构
            场景管理
                场景树
                各种渲染对象属性和方法声明；
                    摄像机
                    网格
                    光源
                        frustum, shadow;
                    Decal
                    envprobe
                    irradiance volume
                对象更新；
            图元分发
                摄像机列表
                渲染图元对象定义；
                图元列表；
                    depth prepass
                    opaque
                    transparent
                    sprite? particle system?
                光源列表
                Decal 列表
                Cubemap 列表
                Irradiance volume 列表
                场景遍历，对象和图元分发
                初始化GL
            材质
                材质对象定义
                    RenderState Cache
                    标准 PBR 材质属性
            RenderTarget
                创建纹理和 RenderBuffer；注意创建的纹理和读取的纹理的关系；
            Shader架构
                Shader 预处理，加载，编译；
                    先用js字符串形式的shader源码测试；
                    实现 #include 机制；
                    以后再实现加载远程 shader 文件？
                命名规则
                Shader 输入、输出定义
                    thin g-buffer, for subsurface scattering, local reflection
                Uniform buffer对象封装
                Uniform buffer 定义：每帧，每View，每物体，每材质
                Uniform buffer 对象放在哪？shaderProgram 对象里？材质对象里？渲染器对象里？
                Uniform buffer 绑定
                渲染器中定义uniform buffer布局
                Vertex Attribute 解析
                Shader 代码结构
                    预置函数，预置变量定义和实现；
                Shader 是否也用缓存？或者为了简单起见，不用缓存了？
                渲染器中加载各种shader；
                    Shader文件和代码段key的命名规则
                    先实现 单色 shader, 测试绘制流程
                    再实现 depth prepass shader, 标准 PBR Shader
                Fix me: Fog 是在材质 Shader 中实现，还是用后期特效实现？
                    不透明物体，可用后期特效
                    半透明物体用材质 shader？
                    或者统一用材质 shader；
            简单Geometry生成、添加、绘制测试
                创建顶点缓冲；Vertex Attribute；Index buffer;
                Box，Sphere，Plane, 用于测试绘制；
                遍历图元列表，绘制
                    光源等非网格对象的 providePrimitive 也得调用，绘制调试图形；
                    Fustum culling; 
                    设置顶点Attribute pointer
                    * 如何在 depth prepass 时使用特殊的 shader？
                        不修改使用的shader；如果关闭了 color write，且 shader 中不使用 discard，则不会执行 shader，opengl 底层会使用一个默认的简单 shader 绘制
                        或者使用一组统一的 shader 来绘制；有镂空纹理的物体不绘制 depth prepass；
                        或者单独写一个带镂空纹理的 depth prepass shader，遇到有 alphaclip = true 的 PBR 材质，则使用这个 shader;
                            PBR 材质的贴图参数统一命名；材质中不带 shader, 使用统一的PBR 标准 shader 绘制；
                            自定义材质的某些贴图参数名称是否也要求统一命名？例如 opacity texture
                    Occlusion query?
                        在RenderItem上加一个是否需要Occlustion query的标志
                        将需要Occlusion query 的RenderItem 挑出来单放一个列表里
                        每帧先绘制不需要 quary 的（例如墙壁、地板、屋顶等），再绘制 query 的（房间中的细节物体）RenderItem 的包围盒
                        本帧 query，下帧才能拿结果，所以每帧都是根据上一帧包围盒的 query 结果绘制细节物体；
                当对象从场景移除时，释放显存资源；
                    加一个显式的 destory 接口？
                简单旋转动画；
                    使用 behavior 控制动画？
                    计时器对象；
                绘制视空间法线；检查背面剔除和法线是否正确；
                摄像机lookat控制？
                
            先实现简单的 forward shading
            直接光照
                添加光源到场景；
                    Shader 中取光源等 item 的函数
                    在 fragment shader 中变换光源到视空间？还是统一用世界空间计算？
                        变换像素的法线和位置到世界空间是否性能更好一些；可以避免将遍历到的每个光源、贴花等都变换到视空间
                PBR 光照计算
                    https://www.cnblogs.com/timlly/p/10631718.html
                多光源；
                测试各种光源类型；
                测试材质的各种参数；
                    TODO: emissive 和 opacity color
                阴影；
                    实现和测试设置 RenderTarget
                        实现和测试画到屏幕的二维矩形 shader
                        渲染到一张纹理，然后贴到场景中的物体表面；
                        屏幕矩形图元；或者屏幕矩形shader；
                        据说 FrameBufferObject 中切换 attached texture 要比切换 FrameBufferObject 快？
                            需要实现 FrameBufferObject 的灵活切换 attached texture 的方法？
                            暂时没必要；持各种观点的人都有，未必对性能影响那么大
                    先测试只有一个光源的阴影；动态光影；
                        实现 shadowmap shader；
                        给光源渲染 shadow map，在屏幕矩形上显示，用于调试
                        使用 depth texture 作为 Shadowmap，传入shader;
                        pbr shader 中计算光照时取样 shadowmap，
                            注意要使用 samplerShadow 类型
                        进一步软阴影；
                        测试不同类型光源的阴影；
                        实现点光源阴影？
                    Shadow map atlas; 
                        如何处理光源的 atlas rect size 变化的情况？还是一旦光源建立，就不允许改了？
                            重构一下，在 lightshadow 上记录 shadow rect 的尺寸，以及当前在 atlas 中的位置；
                            用户只能修改 rect 尺寸；当修改了尺寸后，dispatchobject 时发现与当前尺寸不一致了，就从旧列表中移除，添加到新列表；
                            能否将 lightshadow 和 atlas 位置解耦，将其对应关系以 map 的形式保存在 shadowmapAtlas 对象里？
                                renderer 每次更新 shadowmap 时都需要查询；
                    阴影的动态和静态更新逻辑
                        实现 Frustum culling?
                            有了此功能，才能判断光源中是否有活动的动态物体；
                            给光源生成 frustum
                        网格的包围球和包围盒
                            用包围球可能简单一些；无论怎么变换都是球；
                        静态光源和动态光源的区别：前者不会实时添加或删除，也不能移动或改颜色；后者是实时添加或删除的光源，可以移动、改属性；
                            但是两种类型的光源都可以更新阴影；
                            或者能否利用 unform buffer 的 subData 函数，只更新改变过的光源数据，使所有光源都能修改属性？
                        光源设置一个标志：是否需要更新阴影；维护一个本帧可见光源列表；
                            在光源对象 update 时判断: 如果光源运动了，设为 true；
                            在dispatchObject时，挑出运动的且可投影的物体放到一个列表，与所有当前可见的光源判断是否在其视野中；
                            每帧遍历可见光源且标志为 true，则更新shadowmap，然后将标志置 false;
                        测试物体包围球和光源 frustum 的相交判断；
                        优化：区分动态阴影和静态阴影的意义：
                            使用两张shadowmap，
                            静态shadowmap中只有标记为静态的物体；动态shadowmap中只有标记为动态的物体
                            静态物体的shadowmap可以只生成一次；
                            只有动态物体在光源内运动时，才将该物体绘制到动态shadowmap
                            问题：shader中每个光源都需要sample两张纹理
                        实现简单的相机控制；
                    如何处理带有镂空纹理的材质
                        * 也按照和 depth prepass 类似的方法处理
                    Mesh, light 对相机 Frustum 的剔除；
                    优化：应该通过 gl.BlitFrameBuffer 将静态阴影图集中的子图拷贝到动态阴影图集；
                        维护两个纹理，两个FBO：shadowmapAtlas 和 shadowmapCacheAtlas
                        shader 中只使用 shadowmapAtlas
                        一个标志：cacheDirty
                        当光源运动时
                            清 shadowmapAtlas
                            直接向 ShadowmapAtlas 中渲染静态和动态物体
                            置 cacheDirty = true
                        当光源不动时
                            置 cacheCopied = false;
                            如果 cacheDirty == true,
                                清 shadowmapCacheAtlas; 
                                渲染所有静态物体到 shadowmapCacheAtlas;
                                将 cache 拷贝到 shadowmapAtlas
                                置 cacheCopied = true;
                                置 cacheDirty = false
                            如果光源中有动态物体，则
                                如果 cacheCopied == false，拷贝；
                                向 shadowmapAtlas 中渲染动态物体（不清深度缓冲）

                    点光源的阴影；
                        怎样为点光源阴影申请图集子图？
                            需要向阴影图集中渲染六次；占用六个子图；
                            将列表中的六个元素都记录为该 lightShadow 对象
                            在 lightShadow 中使用一个列表来记录子图矩形？
                            对 shadowmap 分辨率做限制，不能使用太高分辨率的？

                        怎样在 Shader 中使用
                            由于点光源的变换矩阵不用完整传入，只传入一个中心点位置即可，
                                利用 worldMatrix 和 projMatrix 余下的总共 7 个 vec4 传入所有子图的矩形位置？
                            shader 中判断如果是点光源，需要计算像素处于哪个 frustum，获得 cubeface 编号；
                            根据 cubeface 编号计算视空间的三个轴vx, vy, vz;
                                posLightLocal = （像素位置 - 光源位置）;
                                posView.x = dot(posLightLocal, vx);
                                posView.y = dot(posLightLocal, vy);
                                posView.z = dot(posLightLocal, vz); // 实际上这三步可以通过直接取该轴对应的分量完成，简化运算
                                posProj = matShadowProj * posView;  // matShadowProj 是一个统一的矩形常量，可以在光源循环外创建；
                                posNDC = posProj / w;
                                uvw = posNDC 应用子图视口变换；

                        测试
                            做一个比较适合检查点光源投影的场景

            现在的 renderer 类代码有点长了 是否应该重构一下？
                将功能分散在 shadowmaprenderer, cubemaprenderer里？

            间接光照
                RenderTarget; 渲染到cubemap；
                    使用一个 2D Texture atlas? 还是使用 Texture Array？
                    因为 Cubemap 使用统一的尺寸，所以可以考虑使用 Texture Array
                    怎样渲染到 texture array?
                        使用 gl.framebufferTextureLayer
                    调试输出渲染结果；
                    渲染时应该保证足够远的远裁剪面距离；否则远处的物体无法渲到环境贴图上；
                    应该可以设置 envprobe 的背景颜色或天空盒；
                    尝试能否在 shader 中给 RenderTarget 贴图使用 linear 过滤？

                生成 envmap cube（64 x 64）
                    生成 mipmaps？如何进行卷积过滤？
                        封装若干个类干这个事，不要把功能都放在 clusteredForwardRenderer 里
                    diffuse
                        通过黎曼和生成 Diffuse 使用的低分辨率环境贴图，只需要一个mip level
                        参考：https://blog.csdn.net/i_dovelemon/article/details/79091105
                        能否进一步生成 Ambient Cube 或 SH ？
                        取样时注意边缘像素；
                    specular
                        通过 importance sampling  生成 mipmap，每个 level 对应一个 Roughness 下的 LD 项
                        DFG 项是一个预渲染的通用贴图，可以直接加载使用；
                        参考：https://blog.csdn.net/i_dovelemon/article/details/79598921
                            https://blog.csdn.net/i_dovelemon/article/details/79251920

                    diffuse 和 specular 都用同一个 texture2darray；
                        diffuse 放在分辨率较低的一个 level 里
                        specular 放在其他 level 里
                        64x64，7 mip levels
                        0, 1, 2, 3 : specular
                        4: 4x4, diffuse；或者用 1x1 ambient cube? 取样时算法简单一些
                    能否/是否有必要多次渲染envmap，模拟光线多次反射的机制？

                image based lighting
                    shader 中使用的时候，在取样边缘点时从其它面取样过滤？能否预先处理一下 cubemap，将边缘处扩展一下，填充其它面的对应像素？

                    多个 envprobe 的混合
                        权重：距离和尺寸？
                    分别使用 diffuse 和 specular cubemap

                    使用HDR Cubemaps？
                        使用浮点格式 cubemap;
                            Firefox 不支持 RGB float 渲染输出
                            或者向 cubemap 中输出除以一个亮度系数的颜色，在应用时再乘回来？
                        渲染cubemap时，不做 tonemapping；
                        渲染cubemap时，不使用 MRT

                // 生成 irradiance volume？或者尝试用low mipmap envmap cube 做间接光照？
                //    为每个 envmap probe 生成一个 shadowmap，用以剔除影响范围外的物体
                //        该 shadowmap 中只绘制开启了 occlusion query 的静态物体；这样房间内的细节物体的背向 probe 中心点的面不会被剔除，也可以有环境光照。

            SSAO，屏幕空间反射, 屏幕空间 GI？；
                需要输出一个 thin G-buffer；在 Depth prepass 时输出？还是使用MRT，在绘制不透明时输出？参考一下DOOM
                    深度：能否直接使用 depth buffer? 需要恢复出屏幕空间 z
                    normal                                  R16G16
                    specular color (F)  roughness           RGBA8
                需要将主画面输出改为到一个 MRT 上？
                    注意将各 shader 输出也改为 MRT 的
                SSAO shader;

                    改为不是立刻混合到原画面，而是在最后和 SSR、Fog 等一起混合？

                SSR
                    需要保留上一帧画面和速度图？
                        在 DepthPrepass 时生成速度图？
                        上一帧画面必须是应用了Bloom 和 Tonemapping 之前的；但是包括SSAO, SSR，Fog，半透明；
                        半透明只能在前三个特效完成之后绘制；

                        调整 SSR 的不透明度：只使用视角系数和屏幕边界系数，不考虑材质 specular
                    组合结果 Pass：
                        以本帧画面，SSR 画面为输入，做雾效，组合，
                    无法使用屏幕空间反射的像素，使用该像素所属 Cluster 的环境反射贴图？
                        将环境反射贴图的操作推迟到这步后期中进行？不放到 SSR shader 中，避免 cubemap 反射结果被模糊？
                        需要传入法线，镜面反射和粗糙度贴图
                        根据 SSR 结果图的 alpha 通道混合 SSR 结果颜色和 cubemap 反射颜色；需要乘以表面本身的镜面反射颜色？
                        根据视线与法线夹角、镜面反射颜色，求菲涅尔强度计算反射的整体混合系数？
                        改为通过颜色相加的方式混合？因为应该是 Diffuse + specular
                    
                    SSAO 作为 specular occlusion

-----------------------------------------------------

                    对比两种 SSR 的 shader 的效果
                        Unity 5 的
                            优化更好一些，但是不太科学；使用的 roughness 计算反射的强度
                        Babylon.js 中的http://imanolfotia.com/blog/update/2017/03/11/ScreenSpaceReflections.html
                            比较好理解一些，而且根据表面粗糙度对取样方向加了一个扰动；

                        其他参考资料：
                            https://sakibsaikia.github.io/graphics/2016/12/26/Screen-Space-Reflection-in-Killing-Floor-2.html#applying-reflections

                    SSAO blur 效果优化
                        优化取样点和噪声？目前使用随机数取样点效果比较糙
                        尝试改为halton sequence?
                        是否改为使用蓝噪声？
                        
            最终输出：
                做 Bloom 和 Tone mapping，向主屏幕输出
                作为一个后期特效。这样保证在之前的整个渲染流程都是 HDR 线性空间的。
                Tone mapping shader 同时输出画面中高亮度部分和 tone mapping 结果？
                default pbr shader 中不再做 tonemapping；

            半透明物体的绘制？

            Subsurface scattering
                参考 Khronos Group glTF Viewer; Blender;
                使用神海近似的实现方式，还是 screen space subsurface scattering?

            加载贴图
                sampler state
                贴图的属性
                贴图的加载和绑定
                
            Dithered soft shadow?
                使用一个 blue noise dither texture；在做 shadowmap 取样时根据像素屏幕坐标取 dither 偏移量，应用到 shadowmap uv 上？

            FileLoader
            GLTFLoader
                从 Blender 导出测试用的模型
                先直接引用 minimal gltf loader? 或者参考Khronos Group glTF Viewer
                读取mesh, material, texture
                File Cache
                Geometry Cache
                    所有从 gltf 文件加载的 geometry，统一用文件名 + 网格名生成一个key，放在 cache 中；多个 mesh 共享之；
                        注意这种 geometry 要标一下 incache，在对象 release 时避免释放它；由cache统一释放；
                Texture cache
                    用纹理文件 url 作为 key
                读取light, decal, envprobe, irradiance volume;
            
            骨骼皮肤动画
                从 glTF 加载
                shader 绘制

            资源加载器
                资源列表和资源计数？
                所有资源加载完后再开始逻辑循环？
                
        大场景相关

            Clustered 光源、envmap、irradiance volume
                fillItemsPerView
                    加一个参数：checkClusters
                        主画面渲染，设为true;
                        Cubemap 或 Shadowmap 渲染，设为 false；分辨率较低，而且是类似 bake 阶段，无需 Clustered

            Instancing
                can use in mat4 in vertex shader for attribute input;

            测试 Occlusion query?
                调试绘制：Occlusion test 失败的，画一个不会被遮挡的线框 box？或者用不同颜色线框区分被遮挡/无遮挡的物体
                Occlusion query object 分组；
                    用 instancing 方式绘制组内每个 box？还是绘制组的总 AABB？
                        绘制每个 box 是否精确一些；

            particle system; sprite;

            从GLTF加载组件信息？
                读取object的自定义属性：组件列表和组件属性？或者prefab文件名？
                或者使用命名规范、前缀来定义；
                使用json定义object prefab对象；
                区分哪些网格是 occluder，哪些网格需要 occlusion query；使用前缀？
                Blender 中的光源属性是否齐全？怎样使用；导出光源场景测试
                Blender 中能否导出 instancing 的网格？导出有 linked duplicate 网格场景测试