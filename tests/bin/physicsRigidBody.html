<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Rigid Bodies Demo</title>
    <link rel="stylesheet" type="text/css" href="tests.css">
</head>
<style>
</style>
<body>
    <div>
        <div id="infoPanel" class="infoPanel">FPS: 0</div>
        <div id="ctrlPanel" class="controlPanel">
            <div class="controlPanelTitle">Control Panel</div>
        </div>
        <canvas id="mainCanvas" width="1280" height="720"></canvas>
    </div>
    <script type="module">
        import * as CANNON from "./js/tests/bin/js/lib/cannon/cannon-es.js";
        import { GLDevice, ClusteredForwardRenderer, Scene, PerspectiveCamera, Mesh, BoxGeometry, StandardPBRMaterial, Clock, SphereGeometry, CylinderGeometry, PlaneGeometry, DirectionalLight, LoadingManager, TextureLoader, TextureCube, ImageLoader, SamplerState, EnvironmentProbeType } from "./js/tests/bin/js/src/mini3DEngine.js";
        import vec3 from "./js/tests/bin/js/lib/tsm/vec3.js";
        import { AutoRotateBehavior } from "./js/tests/bin/js/tests/common/behaviors/autoRotateBehavior.js";
        import vec4 from "./js/tests/bin/js/lib/tsm/vec4.js";
        import { LookatBehavior } from "./js/tests/bin/js/common/behaviors/lookatBehavior.js";
        import { FirstPersonViewBehavior } from "./js/tests/bin/js/common/behaviors/firstPersonViewBehavior.js";
        import mat4 from "./js/tests/bin/js/lib/tsm/mat4.js";
        import { SceneHelper } from "./js/tests/bin/js/common/sceneHelper.js";
        window.onload = () => {
            const canvas = document.getElementById("mainCanvas");
            if (!canvas) {
                console.error("Canvas not found");
                return;
            }
            GLDevice.initialize(canvas);
            const world = new CANNON.World();
            const loadingManager = new LoadingManager();
            const imageLoader = new ImageLoader(loadingManager);
            const textureLoader = new TextureLoader(loadingManager);
            const renderer = new ClusteredForwardRenderer();
            const scene = new Scene();
            const camera = new PerspectiveCamera();
            camera.aspect = canvas.width / canvas.height;
            camera.far = 20;
            camera.localTransform.fromTranslation(new vec3([0, 0, 2]));
            camera.autoUpdateTransform = false;
            const fpsBehavior = new FirstPersonViewBehavior(camera);
            camera.behaviors.push(fpsBehavior);
            fpsBehavior.position = new vec3([0, 0, 2]);
            scene.attachChild(camera);
            window.onmousedown = (ev) => {
                fpsBehavior.onMouseDown(ev);
            };
            window.onmouseup = (ev) => {
                fpsBehavior.onMouseUp(ev);
            };
            window.onmousemove = (ev) => {
                fpsBehavior.onMouseMove(ev);
            };
            window.onkeydown = (ev) => {
                fpsBehavior.onKeyDown(ev);
            };
            window.onkeyup = (ev) => {
                fpsBehavior.onKeyUp(ev);
            };
            const boxMesh = new Mesh();
            boxMesh.name = "box01";
            boxMesh.geometry = new BoxGeometry(0.25, 0.25, 0.25);
            boxMesh.castShadow = true;
            boxMesh.isStatic = false;
            boxMesh.autoUpdateTransform = false;
            const boxMtl = new StandardPBRMaterial();
            boxMtl.color = new vec4([1.0, 1.0, 0.0, 1.0]);
            boxMtl.metallic = 0.8;
            boxMtl.roughness = 0.4;
            boxMesh.materials.push(boxMtl);
            const boxAutoRot = new AutoRotateBehavior(boxMesh);
            boxMesh.behaviors.push(boxAutoRot);
            scene.attachChild(boxMesh);
            {
                const sphereMesh = new Mesh();
                sphereMesh.name = "sphere.Dynamic";
                sphereMesh.localTransform.fromTranslation(new vec3([0, 0, 0.75]));
                sphereMesh.geometry = new SphereGeometry(0.2, 16, 8);
                sphereMesh.castShadow = true;
                sphereMesh.isStatic = false;
                sphereMesh.autoUpdateTransform = false;
                const sphereMtl = new StandardPBRMaterial();
                sphereMtl.color = new vec4([1.0, 1.0, 1.0, 1.0]);
                sphereMtl.metallic = 0.9;
                sphereMtl.roughness = 0.5;
                sphereMtl.subsurface = 0.15;
                sphereMtl.subsurfaceColor = new vec3([0.4, 0.06, 0.0]);
                sphereMesh.materials.push(sphereMtl);
                boxMesh.attachChild(sphereMesh);
            }
            {
                const sphereMesh = new Mesh();
                sphereMesh.name = "sphere.Static";
                sphereMesh.localTransform.fromTranslation(new vec3([-0.75, -1.2, 0]));
                sphereMesh.geometry = new SphereGeometry(0.4, 16, 8);
                sphereMesh.castShadow = true;
                sphereMesh.isStatic = true;
                sphereMesh.autoUpdateTransform = false;
                const sphereMtl = new StandardPBRMaterial();
                sphereMtl.color = new vec4([1.0, 1.0, 1.0, 1.0]);
                sphereMtl.metallic = 0.05;
                sphereMtl.roughness = 0.95;
                sphereMesh.materials.push(sphereMtl);
                scene.attachChild(sphereMesh);
            }
            const cylinderMesh = new Mesh();
            cylinderMesh.name = "cylinder01";
            cylinderMesh.localTransform.fromTranslation(new vec3([0.75, 0, 0]));
            cylinderMesh.geometry = new CylinderGeometry(0.25, 0.5, 24);
            cylinderMesh.castShadow = true;
            cylinderMesh.isStatic = true;
            cylinderMesh.autoUpdateTransform = false;
            const cylinderMtl = new StandardPBRMaterial();
            cylinderMtl.color = new vec4([0.0, 1.0, 0.0, 1.0]);
            cylinderMtl.emissive = new vec4([0.5, 0.5, 0.5, 1]);
            cylinderMtl.metallic = 0.2;
            cylinderMtl.roughness = 0.6;
            cylinderMesh.materials.push(cylinderMtl);
            scene.attachChild(cylinderMesh);
            const matPlaneRot = new mat4();
            const matPlaneTran = new mat4();
            matPlaneRot.setIdentity();
            matPlaneTran.fromTranslation(new vec3([0, -2, 0]));
            addPlane("floor", matPlaneTran, matPlaneRot, new vec4([1.0, 1.0, 1.0, 1.0]), 0.5, 0.5, scene);
            const dirLight01 = new DirectionalLight();
            dirLight01.isStatic = true;
            dirLight01.autoUpdateTransform = false;
            dirLight01.on = true;
            dirLight01.color = new vec4([3, 3, 3, 1]);
            dirLight01.radius = 5;
            dirLight01.castShadow = true;
            dirLight01.shadow.range = 15;
            const dirLightLookAt = new LookatBehavior(dirLight01);
            dirLight01.behaviors.push(dirLightLookAt);
            dirLightLookAt.position = new vec3([5, 5, 5]);
            dirLightLookAt.target = new vec3([0, 0, 0]);
            dirLightLookAt.up = new vec3([0, 1, 0]);
            scene.attachChild(dirLight01);
            SceneHelper.addEnvProbe("envProbe01", 6, new vec3([0, 0, 0]), scene, EnvironmentProbeType.Reflection);
            SceneHelper.addEnvProbe("irrProbe01", 6, new vec3([0, 0, 0]), scene, EnvironmentProbeType.Irradiance);
            const infoPanel = document.getElementById("infoPanel");
            let lastUpdateFPSTime = 0;
            let curFPS = 0;
            function gameLoop(now) {
                Clock.instance.update(now);
                scene.updateBehavior();
                scene.updateWorldTransform(false, true);
                renderer.render(scene);
                if (now - lastUpdateFPSTime > 1000) {
                    infoPanel.innerHTML = curFPS.toString();
                    lastUpdateFPSTime = now;
                    curFPS = 0;
                }
                curFPS++;
                requestAnimationFrame(gameLoop);
            }
            const envmapUrls = [
                "./textures/skyboxes/ballroom/px.png",
                "./textures/skyboxes/ballroom/nx.png",
                "./textures/skyboxes/ballroom/py.png",
                "./textures/skyboxes/ballroom/ny.png",
                "./textures/skyboxes/ballroom/pz.png",
                "./textures/skyboxes/ballroom/nz.png",
            ];
            const skyboxTexture = new TextureCube();
            for (let i = 0; i < 6; i++) {
                skyboxTexture.images[i] = imageLoader.load(envmapUrls[i], undefined, undefined, (ev) => {
                    console.error("failed loading image.");
                });
            }
            loadingManager.onLoad = () => {
                skyboxTexture.componentType = GLDevice.gl.UNSIGNED_BYTE;
                skyboxTexture.format = GLDevice.gl.RGB;
                skyboxTexture.depth = 1;
                skyboxTexture.width = skyboxTexture.images[0].width;
                skyboxTexture.height = skyboxTexture.images[0].height;
                skyboxTexture.mipLevels = 1;
                skyboxTexture.samplerState = new SamplerState();
                skyboxTexture.upload();
                scene.background = skyboxTexture;
                Clock.instance.start();
                requestAnimationFrame(gameLoop);
            };
            function addPlane(name, matPlaneTran, matPlaneRot, wallColor, metallic, roughness, scene, textureUrl) {
                const planeMesh = new Mesh();
                planeMesh.name = name;
                mat4.product(matPlaneTran, matPlaneRot, planeMesh.localTransform);
                planeMesh.geometry = new PlaneGeometry(4, 4, 1, 1);
                planeMesh.castShadow = true;
                planeMesh.isStatic = true;
                planeMesh.autoUpdateTransform = false;
                const planeMtl = new StandardPBRMaterial();
                planeMtl.color = wallColor.copy();
                planeMtl.metallic = metallic;
                planeMtl.roughness = roughness;
                if (textureUrl !== undefined) {
                    planeMtl.colorMap = textureLoader.load(textureUrl, (texture) => {
                        planeMtl.colorMapAmount = 1.0;
                    });
                }
                planeMesh.materials.push(planeMtl);
                scene.attachChild(planeMesh);
            }
        };
    </script>

</body>
</html>